// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// PlayerProgress is an object representing the database table.
type PlayerProgress struct {
	ID       int      `boil:"id" json:"id" toml:"id" yaml:"id"`
	PlayerID null.Int `boil:"player_id" json:"player_id,omitempty" toml:"player_id" yaml:"player_id,omitempty"`
	// when 1 it means the stats are from the official game, when 0 it's from our own servers
	IsOfficial          int8      `boil:"is_official" json:"is_official" toml:"is_official" yaml:"is_official"`
	KillCount           null.Uint `boil:"kill_count" json:"kill_count,omitempty" toml:"kill_count" yaml:"kill_count,omitempty"`
	DeathCount          null.Uint `boil:"death_count" json:"death_count,omitempty" toml:"death_count" yaml:"death_count,omitempty"`
	LeaderKills         null.Uint `boil:"leader_kills" json:"leader_kills,omitempty" toml:"leader_kills" yaml:"leader_kills,omitempty"`
	AssaultKills        null.Uint `boil:"assault_kills" json:"assault_kills,omitempty" toml:"assault_kills" yaml:"assault_kills,omitempty"`
	MedicKills          null.Uint `boil:"medic_kills" json:"medic_kills,omitempty" toml:"medic_kills" yaml:"medic_kills,omitempty"`
	EngineerKills       null.Uint `boil:"engineer_kills" json:"engineer_kills,omitempty" toml:"engineer_kills" yaml:"engineer_kills,omitempty"`
	SupportKills        null.Uint `boil:"support_kills" json:"support_kills,omitempty" toml:"support_kills" yaml:"support_kills,omitempty"`
	ReconKills          null.Uint `boil:"recon_kills" json:"recon_kills,omitempty" toml:"recon_kills" yaml:"recon_kills,omitempty"`
	WinCount            null.Uint `boil:"win_count" json:"win_count,omitempty" toml:"win_count" yaml:"win_count,omitempty"`
	LoseCount           null.Uint `boil:"lose_count" json:"lose_count,omitempty" toml:"lose_count" yaml:"lose_count,omitempty"`
	FriendlyShots       null.Uint `boil:"friendly_shots" json:"friendly_shots,omitempty" toml:"friendly_shots" yaml:"friendly_shots,omitempty"`
	FriendlyKills       null.Uint `boil:"friendly_kills" json:"friendly_kills,omitempty" toml:"friendly_kills" yaml:"friendly_kills,omitempty"`
	Revived             null.Uint `boil:"revived" json:"revived,omitempty" toml:"revived" yaml:"revived,omitempty"`
	RevivedTeamMates    null.Uint `boil:"revived_team_mates" json:"revived_team_mates,omitempty" toml:"revived_team_mates" yaml:"revived_team_mates,omitempty"`
	Assists             null.Uint `boil:"assists" json:"assists,omitempty" toml:"assists" yaml:"assists,omitempty"`
	Prestige            null.Uint `boil:"prestige" json:"prestige,omitempty" toml:"prestige" yaml:"prestige,omitempty"`
	CurrentRank         null.Uint `boil:"current_rank" json:"current_rank,omitempty" toml:"current_rank" yaml:"current_rank,omitempty"`
	Exp                 null.Uint `boil:"exp" json:"exp,omitempty" toml:"exp" yaml:"exp,omitempty"`
	ShotsFired          null.Uint `boil:"shots_fired" json:"shots_fired,omitempty" toml:"shots_fired" yaml:"shots_fired,omitempty"`
	ShotsHit            null.Uint `boil:"shots_hit" json:"shots_hit,omitempty" toml:"shots_hit" yaml:"shots_hit,omitempty"`
	Headshots           null.Uint `boil:"headshots" json:"headshots,omitempty" toml:"headshots" yaml:"headshots,omitempty"`
	CompletedObjectives null.Uint `boil:"completed_objectives" json:"completed_objectives,omitempty" toml:"completed_objectives" yaml:"completed_objectives,omitempty"`
	HealedHPS           null.Uint `boil:"healed_hps" json:"healed_hps,omitempty" toml:"healed_hps" yaml:"healed_hps,omitempty"`
	RoadKills           null.Uint `boil:"road_kills" json:"road_kills,omitempty" toml:"road_kills" yaml:"road_kills,omitempty"`
	Suicides            null.Uint `boil:"suicides" json:"suicides,omitempty" toml:"suicides" yaml:"suicides,omitempty"`
	VehiclesDestroyed   null.Uint `boil:"vehicles_destroyed" json:"vehicles_destroyed,omitempty" toml:"vehicles_destroyed" yaml:"vehicles_destroyed,omitempty"`
	VehicleHPRepaired   null.Uint `boil:"vehicle_hp_repaired" json:"vehicle_hp_repaired,omitempty" toml:"vehicle_hp_repaired" yaml:"vehicle_hp_repaired,omitempty"`
	LongestKill         null.Uint `boil:"longest_kill" json:"longest_kill,omitempty" toml:"longest_kill" yaml:"longest_kill,omitempty"`
	PlayTimeSeconds     null.Uint `boil:"play_time_seconds" json:"play_time_seconds,omitempty" toml:"play_time_seconds" yaml:"play_time_seconds,omitempty"`
	LeaderPlayTime      null.Uint `boil:"leader_play_time" json:"leader_play_time,omitempty" toml:"leader_play_time" yaml:"leader_play_time,omitempty"`
	AssaultPlayTime     null.Uint `boil:"assault_play_time" json:"assault_play_time,omitempty" toml:"assault_play_time" yaml:"assault_play_time,omitempty"`
	MedicPlayTime       null.Uint `boil:"medic_play_time" json:"medic_play_time,omitempty" toml:"medic_play_time" yaml:"medic_play_time,omitempty"`
	EngineerPlayTime    null.Uint `boil:"engineer_play_time" json:"engineer_play_time,omitempty" toml:"engineer_play_time" yaml:"engineer_play_time,omitempty"`
	SupportPlayTime     null.Uint `boil:"support_play_time" json:"support_play_time,omitempty" toml:"support_play_time" yaml:"support_play_time,omitempty"`
	ReconPlayTime       null.Uint `boil:"recon_play_time" json:"recon_play_time,omitempty" toml:"recon_play_time" yaml:"recon_play_time,omitempty"`
	LeaderScore         null.Uint `boil:"leader_score" json:"leader_score,omitempty" toml:"leader_score" yaml:"leader_score,omitempty"`
	AssaultScore        null.Uint `boil:"assault_score" json:"assault_score,omitempty" toml:"assault_score" yaml:"assault_score,omitempty"`
	MedicScore          null.Uint `boil:"medic_score" json:"medic_score,omitempty" toml:"medic_score" yaml:"medic_score,omitempty"`
	EngineerScore       null.Uint `boil:"engineer_score" json:"engineer_score,omitempty" toml:"engineer_score" yaml:"engineer_score,omitempty"`
	SupportScore        null.Uint `boil:"support_score" json:"support_score,omitempty" toml:"support_score" yaml:"support_score,omitempty"`
	ReconScore          null.Uint `boil:"recon_score" json:"recon_score,omitempty" toml:"recon_score" yaml:"recon_score,omitempty"`
	TotalScore          null.Uint `boil:"total_score" json:"total_score,omitempty" toml:"total_score" yaml:"total_score,omitempty"`
	CreatedAt           time.Time `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt           time.Time `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`

	R *playerProgressR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L playerProgressL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PlayerProgressColumns = struct {
	ID                  string
	PlayerID            string
	IsOfficial          string
	KillCount           string
	DeathCount          string
	LeaderKills         string
	AssaultKills        string
	MedicKills          string
	EngineerKills       string
	SupportKills        string
	ReconKills          string
	WinCount            string
	LoseCount           string
	FriendlyShots       string
	FriendlyKills       string
	Revived             string
	RevivedTeamMates    string
	Assists             string
	Prestige            string
	CurrentRank         string
	Exp                 string
	ShotsFired          string
	ShotsHit            string
	Headshots           string
	CompletedObjectives string
	HealedHPS           string
	RoadKills           string
	Suicides            string
	VehiclesDestroyed   string
	VehicleHPRepaired   string
	LongestKill         string
	PlayTimeSeconds     string
	LeaderPlayTime      string
	AssaultPlayTime     string
	MedicPlayTime       string
	EngineerPlayTime    string
	SupportPlayTime     string
	ReconPlayTime       string
	LeaderScore         string
	AssaultScore        string
	MedicScore          string
	EngineerScore       string
	SupportScore        string
	ReconScore          string
	TotalScore          string
	CreatedAt           string
	UpdatedAt           string
}{
	ID:                  "id",
	PlayerID:            "player_id",
	IsOfficial:          "is_official",
	KillCount:           "kill_count",
	DeathCount:          "death_count",
	LeaderKills:         "leader_kills",
	AssaultKills:        "assault_kills",
	MedicKills:          "medic_kills",
	EngineerKills:       "engineer_kills",
	SupportKills:        "support_kills",
	ReconKills:          "recon_kills",
	WinCount:            "win_count",
	LoseCount:           "lose_count",
	FriendlyShots:       "friendly_shots",
	FriendlyKills:       "friendly_kills",
	Revived:             "revived",
	RevivedTeamMates:    "revived_team_mates",
	Assists:             "assists",
	Prestige:            "prestige",
	CurrentRank:         "current_rank",
	Exp:                 "exp",
	ShotsFired:          "shots_fired",
	ShotsHit:            "shots_hit",
	Headshots:           "headshots",
	CompletedObjectives: "completed_objectives",
	HealedHPS:           "healed_hps",
	RoadKills:           "road_kills",
	Suicides:            "suicides",
	VehiclesDestroyed:   "vehicles_destroyed",
	VehicleHPRepaired:   "vehicle_hp_repaired",
	LongestKill:         "longest_kill",
	PlayTimeSeconds:     "play_time_seconds",
	LeaderPlayTime:      "leader_play_time",
	AssaultPlayTime:     "assault_play_time",
	MedicPlayTime:       "medic_play_time",
	EngineerPlayTime:    "engineer_play_time",
	SupportPlayTime:     "support_play_time",
	ReconPlayTime:       "recon_play_time",
	LeaderScore:         "leader_score",
	AssaultScore:        "assault_score",
	MedicScore:          "medic_score",
	EngineerScore:       "engineer_score",
	SupportScore:        "support_score",
	ReconScore:          "recon_score",
	TotalScore:          "total_score",
	CreatedAt:           "created_at",
	UpdatedAt:           "updated_at",
}

var PlayerProgressTableColumns = struct {
	ID                  string
	PlayerID            string
	IsOfficial          string
	KillCount           string
	DeathCount          string
	LeaderKills         string
	AssaultKills        string
	MedicKills          string
	EngineerKills       string
	SupportKills        string
	ReconKills          string
	WinCount            string
	LoseCount           string
	FriendlyShots       string
	FriendlyKills       string
	Revived             string
	RevivedTeamMates    string
	Assists             string
	Prestige            string
	CurrentRank         string
	Exp                 string
	ShotsFired          string
	ShotsHit            string
	Headshots           string
	CompletedObjectives string
	HealedHPS           string
	RoadKills           string
	Suicides            string
	VehiclesDestroyed   string
	VehicleHPRepaired   string
	LongestKill         string
	PlayTimeSeconds     string
	LeaderPlayTime      string
	AssaultPlayTime     string
	MedicPlayTime       string
	EngineerPlayTime    string
	SupportPlayTime     string
	ReconPlayTime       string
	LeaderScore         string
	AssaultScore        string
	MedicScore          string
	EngineerScore       string
	SupportScore        string
	ReconScore          string
	TotalScore          string
	CreatedAt           string
	UpdatedAt           string
}{
	ID:                  "player_progress.id",
	PlayerID:            "player_progress.player_id",
	IsOfficial:          "player_progress.is_official",
	KillCount:           "player_progress.kill_count",
	DeathCount:          "player_progress.death_count",
	LeaderKills:         "player_progress.leader_kills",
	AssaultKills:        "player_progress.assault_kills",
	MedicKills:          "player_progress.medic_kills",
	EngineerKills:       "player_progress.engineer_kills",
	SupportKills:        "player_progress.support_kills",
	ReconKills:          "player_progress.recon_kills",
	WinCount:            "player_progress.win_count",
	LoseCount:           "player_progress.lose_count",
	FriendlyShots:       "player_progress.friendly_shots",
	FriendlyKills:       "player_progress.friendly_kills",
	Revived:             "player_progress.revived",
	RevivedTeamMates:    "player_progress.revived_team_mates",
	Assists:             "player_progress.assists",
	Prestige:            "player_progress.prestige",
	CurrentRank:         "player_progress.current_rank",
	Exp:                 "player_progress.exp",
	ShotsFired:          "player_progress.shots_fired",
	ShotsHit:            "player_progress.shots_hit",
	Headshots:           "player_progress.headshots",
	CompletedObjectives: "player_progress.completed_objectives",
	HealedHPS:           "player_progress.healed_hps",
	RoadKills:           "player_progress.road_kills",
	Suicides:            "player_progress.suicides",
	VehiclesDestroyed:   "player_progress.vehicles_destroyed",
	VehicleHPRepaired:   "player_progress.vehicle_hp_repaired",
	LongestKill:         "player_progress.longest_kill",
	PlayTimeSeconds:     "player_progress.play_time_seconds",
	LeaderPlayTime:      "player_progress.leader_play_time",
	AssaultPlayTime:     "player_progress.assault_play_time",
	MedicPlayTime:       "player_progress.medic_play_time",
	EngineerPlayTime:    "player_progress.engineer_play_time",
	SupportPlayTime:     "player_progress.support_play_time",
	ReconPlayTime:       "player_progress.recon_play_time",
	LeaderScore:         "player_progress.leader_score",
	AssaultScore:        "player_progress.assault_score",
	MedicScore:          "player_progress.medic_score",
	EngineerScore:       "player_progress.engineer_score",
	SupportScore:        "player_progress.support_score",
	ReconScore:          "player_progress.recon_score",
	TotalScore:          "player_progress.total_score",
	CreatedAt:           "player_progress.created_at",
	UpdatedAt:           "player_progress.updated_at",
}

// Generated where

type whereHelperint8 struct{ field string }

func (w whereHelperint8) EQ(x int8) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint8) NEQ(x int8) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint8) LT(x int8) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint8) LTE(x int8) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint8) GT(x int8) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint8) GTE(x int8) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint8) IN(slice []int8) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint8) NIN(slice []int8) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Uint struct{ field string }

func (w whereHelpernull_Uint) EQ(x null.Uint) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Uint) NEQ(x null.Uint) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Uint) LT(x null.Uint) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Uint) LTE(x null.Uint) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Uint) GT(x null.Uint) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Uint) GTE(x null.Uint) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Uint) IN(slice []uint) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Uint) NIN(slice []uint) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Uint) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Uint) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var PlayerProgressWhere = struct {
	ID                  whereHelperint
	PlayerID            whereHelpernull_Int
	IsOfficial          whereHelperint8
	KillCount           whereHelpernull_Uint
	DeathCount          whereHelpernull_Uint
	LeaderKills         whereHelpernull_Uint
	AssaultKills        whereHelpernull_Uint
	MedicKills          whereHelpernull_Uint
	EngineerKills       whereHelpernull_Uint
	SupportKills        whereHelpernull_Uint
	ReconKills          whereHelpernull_Uint
	WinCount            whereHelpernull_Uint
	LoseCount           whereHelpernull_Uint
	FriendlyShots       whereHelpernull_Uint
	FriendlyKills       whereHelpernull_Uint
	Revived             whereHelpernull_Uint
	RevivedTeamMates    whereHelpernull_Uint
	Assists             whereHelpernull_Uint
	Prestige            whereHelpernull_Uint
	CurrentRank         whereHelpernull_Uint
	Exp                 whereHelpernull_Uint
	ShotsFired          whereHelpernull_Uint
	ShotsHit            whereHelpernull_Uint
	Headshots           whereHelpernull_Uint
	CompletedObjectives whereHelpernull_Uint
	HealedHPS           whereHelpernull_Uint
	RoadKills           whereHelpernull_Uint
	Suicides            whereHelpernull_Uint
	VehiclesDestroyed   whereHelpernull_Uint
	VehicleHPRepaired   whereHelpernull_Uint
	LongestKill         whereHelpernull_Uint
	PlayTimeSeconds     whereHelpernull_Uint
	LeaderPlayTime      whereHelpernull_Uint
	AssaultPlayTime     whereHelpernull_Uint
	MedicPlayTime       whereHelpernull_Uint
	EngineerPlayTime    whereHelpernull_Uint
	SupportPlayTime     whereHelpernull_Uint
	ReconPlayTime       whereHelpernull_Uint
	LeaderScore         whereHelpernull_Uint
	AssaultScore        whereHelpernull_Uint
	MedicScore          whereHelpernull_Uint
	EngineerScore       whereHelpernull_Uint
	SupportScore        whereHelpernull_Uint
	ReconScore          whereHelpernull_Uint
	TotalScore          whereHelpernull_Uint
	CreatedAt           whereHelpertime_Time
	UpdatedAt           whereHelpertime_Time
}{
	ID:                  whereHelperint{field: "`player_progress`.`id`"},
	PlayerID:            whereHelpernull_Int{field: "`player_progress`.`player_id`"},
	IsOfficial:          whereHelperint8{field: "`player_progress`.`is_official`"},
	KillCount:           whereHelpernull_Uint{field: "`player_progress`.`kill_count`"},
	DeathCount:          whereHelpernull_Uint{field: "`player_progress`.`death_count`"},
	LeaderKills:         whereHelpernull_Uint{field: "`player_progress`.`leader_kills`"},
	AssaultKills:        whereHelpernull_Uint{field: "`player_progress`.`assault_kills`"},
	MedicKills:          whereHelpernull_Uint{field: "`player_progress`.`medic_kills`"},
	EngineerKills:       whereHelpernull_Uint{field: "`player_progress`.`engineer_kills`"},
	SupportKills:        whereHelpernull_Uint{field: "`player_progress`.`support_kills`"},
	ReconKills:          whereHelpernull_Uint{field: "`player_progress`.`recon_kills`"},
	WinCount:            whereHelpernull_Uint{field: "`player_progress`.`win_count`"},
	LoseCount:           whereHelpernull_Uint{field: "`player_progress`.`lose_count`"},
	FriendlyShots:       whereHelpernull_Uint{field: "`player_progress`.`friendly_shots`"},
	FriendlyKills:       whereHelpernull_Uint{field: "`player_progress`.`friendly_kills`"},
	Revived:             whereHelpernull_Uint{field: "`player_progress`.`revived`"},
	RevivedTeamMates:    whereHelpernull_Uint{field: "`player_progress`.`revived_team_mates`"},
	Assists:             whereHelpernull_Uint{field: "`player_progress`.`assists`"},
	Prestige:            whereHelpernull_Uint{field: "`player_progress`.`prestige`"},
	CurrentRank:         whereHelpernull_Uint{field: "`player_progress`.`current_rank`"},
	Exp:                 whereHelpernull_Uint{field: "`player_progress`.`exp`"},
	ShotsFired:          whereHelpernull_Uint{field: "`player_progress`.`shots_fired`"},
	ShotsHit:            whereHelpernull_Uint{field: "`player_progress`.`shots_hit`"},
	Headshots:           whereHelpernull_Uint{field: "`player_progress`.`headshots`"},
	CompletedObjectives: whereHelpernull_Uint{field: "`player_progress`.`completed_objectives`"},
	HealedHPS:           whereHelpernull_Uint{field: "`player_progress`.`healed_hps`"},
	RoadKills:           whereHelpernull_Uint{field: "`player_progress`.`road_kills`"},
	Suicides:            whereHelpernull_Uint{field: "`player_progress`.`suicides`"},
	VehiclesDestroyed:   whereHelpernull_Uint{field: "`player_progress`.`vehicles_destroyed`"},
	VehicleHPRepaired:   whereHelpernull_Uint{field: "`player_progress`.`vehicle_hp_repaired`"},
	LongestKill:         whereHelpernull_Uint{field: "`player_progress`.`longest_kill`"},
	PlayTimeSeconds:     whereHelpernull_Uint{field: "`player_progress`.`play_time_seconds`"},
	LeaderPlayTime:      whereHelpernull_Uint{field: "`player_progress`.`leader_play_time`"},
	AssaultPlayTime:     whereHelpernull_Uint{field: "`player_progress`.`assault_play_time`"},
	MedicPlayTime:       whereHelpernull_Uint{field: "`player_progress`.`medic_play_time`"},
	EngineerPlayTime:    whereHelpernull_Uint{field: "`player_progress`.`engineer_play_time`"},
	SupportPlayTime:     whereHelpernull_Uint{field: "`player_progress`.`support_play_time`"},
	ReconPlayTime:       whereHelpernull_Uint{field: "`player_progress`.`recon_play_time`"},
	LeaderScore:         whereHelpernull_Uint{field: "`player_progress`.`leader_score`"},
	AssaultScore:        whereHelpernull_Uint{field: "`player_progress`.`assault_score`"},
	MedicScore:          whereHelpernull_Uint{field: "`player_progress`.`medic_score`"},
	EngineerScore:       whereHelpernull_Uint{field: "`player_progress`.`engineer_score`"},
	SupportScore:        whereHelpernull_Uint{field: "`player_progress`.`support_score`"},
	ReconScore:          whereHelpernull_Uint{field: "`player_progress`.`recon_score`"},
	TotalScore:          whereHelpernull_Uint{field: "`player_progress`.`total_score`"},
	CreatedAt:           whereHelpertime_Time{field: "`player_progress`.`created_at`"},
	UpdatedAt:           whereHelpertime_Time{field: "`player_progress`.`updated_at`"},
}

// PlayerProgressRels is where relationship names are stored.
var PlayerProgressRels = struct {
	Player string
}{
	Player: "Player",
}

// playerProgressR is where relationships are stored.
type playerProgressR struct {
	Player *Player `boil:"Player" json:"Player" toml:"Player" yaml:"Player"`
}

// NewStruct creates a new relationship struct
func (*playerProgressR) NewStruct() *playerProgressR {
	return &playerProgressR{}
}

func (r *playerProgressR) GetPlayer() *Player {
	if r == nil {
		return nil
	}
	return r.Player
}

// playerProgressL is where Load methods for each relationship are stored.
type playerProgressL struct{}

var (
	playerProgressAllColumns            = []string{"id", "player_id", "is_official", "kill_count", "death_count", "leader_kills", "assault_kills", "medic_kills", "engineer_kills", "support_kills", "recon_kills", "win_count", "lose_count", "friendly_shots", "friendly_kills", "revived", "revived_team_mates", "assists", "prestige", "current_rank", "exp", "shots_fired", "shots_hit", "headshots", "completed_objectives", "healed_hps", "road_kills", "suicides", "vehicles_destroyed", "vehicle_hp_repaired", "longest_kill", "play_time_seconds", "leader_play_time", "assault_play_time", "medic_play_time", "engineer_play_time", "support_play_time", "recon_play_time", "leader_score", "assault_score", "medic_score", "engineer_score", "support_score", "recon_score", "total_score", "created_at", "updated_at"}
	playerProgressColumnsWithoutDefault = []string{"player_id", "is_official"}
	playerProgressColumnsWithDefault    = []string{"id", "kill_count", "death_count", "leader_kills", "assault_kills", "medic_kills", "engineer_kills", "support_kills", "recon_kills", "win_count", "lose_count", "friendly_shots", "friendly_kills", "revived", "revived_team_mates", "assists", "prestige", "current_rank", "exp", "shots_fired", "shots_hit", "headshots", "completed_objectives", "healed_hps", "road_kills", "suicides", "vehicles_destroyed", "vehicle_hp_repaired", "longest_kill", "play_time_seconds", "leader_play_time", "assault_play_time", "medic_play_time", "engineer_play_time", "support_play_time", "recon_play_time", "leader_score", "assault_score", "medic_score", "engineer_score", "support_score", "recon_score", "total_score", "created_at", "updated_at"}
	playerProgressPrimaryKeyColumns     = []string{"id"}
	playerProgressGeneratedColumns      = []string{}
)

type (
	// PlayerProgressSlice is an alias for a slice of pointers to PlayerProgress.
	// This should almost always be used instead of []PlayerProgress.
	PlayerProgressSlice []*PlayerProgress

	playerProgressQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	playerProgressType                 = reflect.TypeOf(&PlayerProgress{})
	playerProgressMapping              = queries.MakeStructMapping(playerProgressType)
	playerProgressPrimaryKeyMapping, _ = queries.BindMapping(playerProgressType, playerProgressMapping, playerProgressPrimaryKeyColumns)
	playerProgressInsertCacheMut       sync.RWMutex
	playerProgressInsertCache          = make(map[string]insertCache)
	playerProgressUpdateCacheMut       sync.RWMutex
	playerProgressUpdateCache          = make(map[string]updateCache)
	playerProgressUpsertCacheMut       sync.RWMutex
	playerProgressUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single playerProgress record from the query.
func (q playerProgressQuery) One(exec boil.Executor) (*PlayerProgress, error) {
	o := &PlayerProgress{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for player_progress")
	}

	return o, nil
}

// All returns all PlayerProgress records from the query.
func (q playerProgressQuery) All(exec boil.Executor) (PlayerProgressSlice, error) {
	var o []*PlayerProgress

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to PlayerProgress slice")
	}

	return o, nil
}

// Count returns the count of all PlayerProgress records in the query.
func (q playerProgressQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count player_progress rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q playerProgressQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if player_progress exists")
	}

	return count > 0, nil
}

// Player pointed to by the foreign key.
func (o *PlayerProgress) Player(mods ...qm.QueryMod) playerQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.PlayerID),
	}

	queryMods = append(queryMods, mods...)

	return Players(queryMods...)
}

// LoadPlayer allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (playerProgressL) LoadPlayer(e boil.Executor, singular bool, maybePlayerProgress interface{}, mods queries.Applicator) error {
	var slice []*PlayerProgress
	var object *PlayerProgress

	if singular {
		var ok bool
		object, ok = maybePlayerProgress.(*PlayerProgress)
		if !ok {
			object = new(PlayerProgress)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayerProgress)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayerProgress))
			}
		}
	} else {
		s, ok := maybePlayerProgress.(*[]*PlayerProgress)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayerProgress)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayerProgress))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerProgressR{}
		}
		if !queries.IsNil(object.PlayerID) {
			args = append(args, object.PlayerID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerProgressR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.PlayerID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.PlayerID) {
				args = append(args, obj.PlayerID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player`),
		qm.WhereIn(`player.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Player")
	}

	var resultSlice []*Player
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Player")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for player")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Player = foreign
		if foreign.R == nil {
			foreign.R = &playerR{}
		}
		foreign.R.PlayerProgresses = append(foreign.R.PlayerProgresses, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.PlayerID, foreign.ID) {
				local.R.Player = foreign
				if foreign.R == nil {
					foreign.R = &playerR{}
				}
				foreign.R.PlayerProgresses = append(foreign.R.PlayerProgresses, local)
				break
			}
		}
	}

	return nil
}

// SetPlayer of the playerProgress to the related item.
// Sets o.R.Player to related.
// Adds o to related.R.PlayerProgresses.
func (o *PlayerProgress) SetPlayer(exec boil.Executor, insert bool, related *Player) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `player_progress` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"player_id"}),
		strmangle.WhereClause("`", "`", 0, playerProgressPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.PlayerID, related.ID)
	if o.R == nil {
		o.R = &playerProgressR{
			Player: related,
		}
	} else {
		o.R.Player = related
	}

	if related.R == nil {
		related.R = &playerR{
			PlayerProgresses: PlayerProgressSlice{o},
		}
	} else {
		related.R.PlayerProgresses = append(related.R.PlayerProgresses, o)
	}

	return nil
}

// RemovePlayer relationship.
// Sets o.R.Player to nil.
// Removes o from all passed in related items' relationships struct.
func (o *PlayerProgress) RemovePlayer(exec boil.Executor, related *Player) error {
	var err error

	queries.SetScanner(&o.PlayerID, nil)
	if err = o.Update(exec, boil.Whitelist("player_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Player = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.PlayerProgresses {
		if queries.Equal(o.PlayerID, ri.PlayerID) {
			continue
		}

		ln := len(related.R.PlayerProgresses)
		if ln > 1 && i < ln-1 {
			related.R.PlayerProgresses[i] = related.R.PlayerProgresses[ln-1]
		}
		related.R.PlayerProgresses = related.R.PlayerProgresses[:ln-1]
		break
	}
	return nil
}

// PlayerProgresses retrieves all the records using an executor.
func PlayerProgresses(mods ...qm.QueryMod) playerProgressQuery {
	mods = append(mods, qm.From("`player_progress`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`player_progress`.*"})
	}

	return playerProgressQuery{q}
}

// FindPlayerProgress retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPlayerProgress(exec boil.Executor, iD int, selectCols ...string) (*PlayerProgress, error) {
	playerProgressObj := &PlayerProgress{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `player_progress` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, playerProgressObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from player_progress")
	}

	return playerProgressObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *PlayerProgress) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no player_progress provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(playerProgressColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	playerProgressInsertCacheMut.RLock()
	cache, cached := playerProgressInsertCache[key]
	playerProgressInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			playerProgressAllColumns,
			playerProgressColumnsWithDefault,
			playerProgressColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(playerProgressType, playerProgressMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(playerProgressType, playerProgressMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `player_progress` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `player_progress` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `player_progress` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, playerProgressPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	result, err := exec.Exec(cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into player_progress")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == playerProgressMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}
	err = exec.QueryRow(cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for player_progress")
	}

CacheNoHooks:
	if !cached {
		playerProgressInsertCacheMut.Lock()
		playerProgressInsertCache[key] = cache
		playerProgressInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the PlayerProgress.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *PlayerProgress) Update(exec boil.Executor, columns boil.Columns) error {
	var err error
	key := makeCacheKey(columns, nil)
	playerProgressUpdateCacheMut.RLock()
	cache, cached := playerProgressUpdateCache[key]
	playerProgressUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			playerProgressAllColumns,
			playerProgressPrimaryKeyColumns,
		)
		if len(wl) == 0 {
			return errors.New("model: unable to update player_progress, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `player_progress` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, playerProgressPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(playerProgressType, playerProgressMapping, append(wl, playerProgressPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err = exec.Exec(cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "model: unable to update player_progress row")
	}

	if !cached {
		playerProgressUpdateCacheMut.Lock()
		playerProgressUpdateCache[key] = cache
		playerProgressUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q playerProgressQuery) UpdateAll(exec boil.Executor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.Exec(exec)
	if err != nil {
		return errors.Wrap(err, "model: unable to update all for player_progress")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PlayerProgressSlice) UpdateAll(exec boil.Executor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerProgressPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `player_progress` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, playerProgressPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "model: unable to update all in playerProgress slice")
	}

	return nil
}

var mySQLPlayerProgressUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *PlayerProgress) Upsert(exec boil.Executor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("model: no player_progress provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(playerProgressColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLPlayerProgressUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	playerProgressUpsertCacheMut.RLock()
	cache, cached := playerProgressUpsertCache[key]
	playerProgressUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			playerProgressAllColumns,
			playerProgressColumnsWithDefault,
			playerProgressColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			playerProgressAllColumns,
			playerProgressPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("model: unable to upsert player_progress, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`player_progress`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `player_progress` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(playerProgressType, playerProgressMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(playerProgressType, playerProgressMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	result, err := exec.Exec(cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to upsert for player_progress")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == playerProgressMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(playerProgressType, playerProgressMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "model: unable to retrieve unique values for player_progress")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}
	err = exec.QueryRow(cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for player_progress")
	}

CacheNoHooks:
	if !cached {
		playerProgressUpsertCacheMut.Lock()
		playerProgressUpsertCache[key] = cache
		playerProgressUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single PlayerProgress record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *PlayerProgress) Delete(exec boil.Executor) error {
	if o == nil {
		return errors.New("model: no PlayerProgress provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), playerProgressPrimaryKeyMapping)
	sql := "DELETE FROM `player_progress` WHERE `id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "model: unable to delete from player_progress")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q playerProgressQuery) DeleteAll(exec boil.Executor) error {
	if q.Query == nil {
		return errors.New("model: no playerProgressQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.Exec(exec)
	if err != nil {
		return errors.Wrap(err, "model: unable to delete all from player_progress")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PlayerProgressSlice) DeleteAll(exec boil.Executor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerProgressPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `player_progress` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, playerProgressPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "model: unable to delete all from playerProgress slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *PlayerProgress) Reload(exec boil.Executor) error {
	ret, err := FindPlayerProgress(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PlayerProgressSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PlayerProgressSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerProgressPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `player_progress`.* FROM `player_progress` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, playerProgressPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in PlayerProgressSlice")
	}

	*o = slice

	return nil
}

// PlayerProgressExists checks if the PlayerProgress row exists.
func PlayerProgressExists(exec boil.Executor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `player_progress` where `id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if player_progress exists")
	}

	return exists, nil
}

// Exists checks if the PlayerProgress row exists.
func (o *PlayerProgress) Exists(exec boil.Executor) (bool, error) {
	return PlayerProgressExists(exec, o.ID)
}
