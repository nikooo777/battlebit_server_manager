// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package model

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// PlayerProgress is an object representing the database table.
type PlayerProgress struct {
	ID       int `boil:"id" json:"id" toml:"id" yaml:"id"`
	PlayerID int `boil:"player_id" json:"player_id" toml:"player_id" yaml:"player_id"`
	// when 1 it means the stats are from the official game, when 0 it's from our own servers
	IsOfficial          int8      `boil:"is_official" json:"is_official" toml:"is_official" yaml:"is_official"`
	KillCount           uint      `boil:"kill_count" json:"kill_count" toml:"kill_count" yaml:"kill_count"`
	DeathCount          uint      `boil:"death_count" json:"death_count" toml:"death_count" yaml:"death_count"`
	LeaderKills         uint      `boil:"leader_kills" json:"leader_kills" toml:"leader_kills" yaml:"leader_kills"`
	AssaultKills        uint      `boil:"assault_kills" json:"assault_kills" toml:"assault_kills" yaml:"assault_kills"`
	MedicKills          uint      `boil:"medic_kills" json:"medic_kills" toml:"medic_kills" yaml:"medic_kills"`
	EngineerKills       uint      `boil:"engineer_kills" json:"engineer_kills" toml:"engineer_kills" yaml:"engineer_kills"`
	SupportKills        uint      `boil:"support_kills" json:"support_kills" toml:"support_kills" yaml:"support_kills"`
	ReconKills          uint      `boil:"recon_kills" json:"recon_kills" toml:"recon_kills" yaml:"recon_kills"`
	WinCount            uint      `boil:"win_count" json:"win_count" toml:"win_count" yaml:"win_count"`
	LoseCount           uint      `boil:"lose_count" json:"lose_count" toml:"lose_count" yaml:"lose_count"`
	FriendlyShots       uint      `boil:"friendly_shots" json:"friendly_shots" toml:"friendly_shots" yaml:"friendly_shots"`
	FriendlyKills       uint      `boil:"friendly_kills" json:"friendly_kills" toml:"friendly_kills" yaml:"friendly_kills"`
	Revived             uint      `boil:"revived" json:"revived" toml:"revived" yaml:"revived"`
	RevivedTeamMates    uint      `boil:"revived_team_mates" json:"revived_team_mates" toml:"revived_team_mates" yaml:"revived_team_mates"`
	Assists             uint      `boil:"assists" json:"assists" toml:"assists" yaml:"assists"`
	Prestige            uint      `boil:"prestige" json:"prestige" toml:"prestige" yaml:"prestige"`
	CurrentRank         uint      `boil:"current_rank" json:"current_rank" toml:"current_rank" yaml:"current_rank"`
	Exp                 uint      `boil:"exp" json:"exp" toml:"exp" yaml:"exp"`
	ShotsFired          uint      `boil:"shots_fired" json:"shots_fired" toml:"shots_fired" yaml:"shots_fired"`
	ShotsHit            uint      `boil:"shots_hit" json:"shots_hit" toml:"shots_hit" yaml:"shots_hit"`
	Headshots           uint      `boil:"headshots" json:"headshots" toml:"headshots" yaml:"headshots"`
	CompletedObjectives uint      `boil:"completed_objectives" json:"completed_objectives" toml:"completed_objectives" yaml:"completed_objectives"`
	HealedHPS           uint      `boil:"healed_hps" json:"healed_hps" toml:"healed_hps" yaml:"healed_hps"`
	RoadKills           uint      `boil:"road_kills" json:"road_kills" toml:"road_kills" yaml:"road_kills"`
	Suicides            uint      `boil:"suicides" json:"suicides" toml:"suicides" yaml:"suicides"`
	VehiclesDestroyed   uint      `boil:"vehicles_destroyed" json:"vehicles_destroyed" toml:"vehicles_destroyed" yaml:"vehicles_destroyed"`
	VehicleHPRepaired   uint      `boil:"vehicle_hp_repaired" json:"vehicle_hp_repaired" toml:"vehicle_hp_repaired" yaml:"vehicle_hp_repaired"`
	LongestKill         uint      `boil:"longest_kill" json:"longest_kill" toml:"longest_kill" yaml:"longest_kill"`
	PlayTimeSeconds     uint      `boil:"play_time_seconds" json:"play_time_seconds" toml:"play_time_seconds" yaml:"play_time_seconds"`
	LeaderPlayTime      uint      `boil:"leader_play_time" json:"leader_play_time" toml:"leader_play_time" yaml:"leader_play_time"`
	AssaultPlayTime     uint      `boil:"assault_play_time" json:"assault_play_time" toml:"assault_play_time" yaml:"assault_play_time"`
	MedicPlayTime       uint      `boil:"medic_play_time" json:"medic_play_time" toml:"medic_play_time" yaml:"medic_play_time"`
	EngineerPlayTime    uint      `boil:"engineer_play_time" json:"engineer_play_time" toml:"engineer_play_time" yaml:"engineer_play_time"`
	SupportPlayTime     uint      `boil:"support_play_time" json:"support_play_time" toml:"support_play_time" yaml:"support_play_time"`
	ReconPlayTime       uint      `boil:"recon_play_time" json:"recon_play_time" toml:"recon_play_time" yaml:"recon_play_time"`
	LeaderScore         uint      `boil:"leader_score" json:"leader_score" toml:"leader_score" yaml:"leader_score"`
	AssaultScore        uint      `boil:"assault_score" json:"assault_score" toml:"assault_score" yaml:"assault_score"`
	MedicScore          uint      `boil:"medic_score" json:"medic_score" toml:"medic_score" yaml:"medic_score"`
	EngineerScore       uint      `boil:"engineer_score" json:"engineer_score" toml:"engineer_score" yaml:"engineer_score"`
	SupportScore        uint      `boil:"support_score" json:"support_score" toml:"support_score" yaml:"support_score"`
	ReconScore          uint      `boil:"recon_score" json:"recon_score" toml:"recon_score" yaml:"recon_score"`
	TotalScore          uint      `boil:"total_score" json:"total_score" toml:"total_score" yaml:"total_score"`
	CreatedAt           time.Time `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt           time.Time `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`

	R *playerProgressR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L playerProgressL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PlayerProgressColumns = struct {
	ID                  string
	PlayerID            string
	IsOfficial          string
	KillCount           string
	DeathCount          string
	LeaderKills         string
	AssaultKills        string
	MedicKills          string
	EngineerKills       string
	SupportKills        string
	ReconKills          string
	WinCount            string
	LoseCount           string
	FriendlyShots       string
	FriendlyKills       string
	Revived             string
	RevivedTeamMates    string
	Assists             string
	Prestige            string
	CurrentRank         string
	Exp                 string
	ShotsFired          string
	ShotsHit            string
	Headshots           string
	CompletedObjectives string
	HealedHPS           string
	RoadKills           string
	Suicides            string
	VehiclesDestroyed   string
	VehicleHPRepaired   string
	LongestKill         string
	PlayTimeSeconds     string
	LeaderPlayTime      string
	AssaultPlayTime     string
	MedicPlayTime       string
	EngineerPlayTime    string
	SupportPlayTime     string
	ReconPlayTime       string
	LeaderScore         string
	AssaultScore        string
	MedicScore          string
	EngineerScore       string
	SupportScore        string
	ReconScore          string
	TotalScore          string
	CreatedAt           string
	UpdatedAt           string
}{
	ID:                  "id",
	PlayerID:            "player_id",
	IsOfficial:          "is_official",
	KillCount:           "kill_count",
	DeathCount:          "death_count",
	LeaderKills:         "leader_kills",
	AssaultKills:        "assault_kills",
	MedicKills:          "medic_kills",
	EngineerKills:       "engineer_kills",
	SupportKills:        "support_kills",
	ReconKills:          "recon_kills",
	WinCount:            "win_count",
	LoseCount:           "lose_count",
	FriendlyShots:       "friendly_shots",
	FriendlyKills:       "friendly_kills",
	Revived:             "revived",
	RevivedTeamMates:    "revived_team_mates",
	Assists:             "assists",
	Prestige:            "prestige",
	CurrentRank:         "current_rank",
	Exp:                 "exp",
	ShotsFired:          "shots_fired",
	ShotsHit:            "shots_hit",
	Headshots:           "headshots",
	CompletedObjectives: "completed_objectives",
	HealedHPS:           "healed_hps",
	RoadKills:           "road_kills",
	Suicides:            "suicides",
	VehiclesDestroyed:   "vehicles_destroyed",
	VehicleHPRepaired:   "vehicle_hp_repaired",
	LongestKill:         "longest_kill",
	PlayTimeSeconds:     "play_time_seconds",
	LeaderPlayTime:      "leader_play_time",
	AssaultPlayTime:     "assault_play_time",
	MedicPlayTime:       "medic_play_time",
	EngineerPlayTime:    "engineer_play_time",
	SupportPlayTime:     "support_play_time",
	ReconPlayTime:       "recon_play_time",
	LeaderScore:         "leader_score",
	AssaultScore:        "assault_score",
	MedicScore:          "medic_score",
	EngineerScore:       "engineer_score",
	SupportScore:        "support_score",
	ReconScore:          "recon_score",
	TotalScore:          "total_score",
	CreatedAt:           "created_at",
	UpdatedAt:           "updated_at",
}

var PlayerProgressTableColumns = struct {
	ID                  string
	PlayerID            string
	IsOfficial          string
	KillCount           string
	DeathCount          string
	LeaderKills         string
	AssaultKills        string
	MedicKills          string
	EngineerKills       string
	SupportKills        string
	ReconKills          string
	WinCount            string
	LoseCount           string
	FriendlyShots       string
	FriendlyKills       string
	Revived             string
	RevivedTeamMates    string
	Assists             string
	Prestige            string
	CurrentRank         string
	Exp                 string
	ShotsFired          string
	ShotsHit            string
	Headshots           string
	CompletedObjectives string
	HealedHPS           string
	RoadKills           string
	Suicides            string
	VehiclesDestroyed   string
	VehicleHPRepaired   string
	LongestKill         string
	PlayTimeSeconds     string
	LeaderPlayTime      string
	AssaultPlayTime     string
	MedicPlayTime       string
	EngineerPlayTime    string
	SupportPlayTime     string
	ReconPlayTime       string
	LeaderScore         string
	AssaultScore        string
	MedicScore          string
	EngineerScore       string
	SupportScore        string
	ReconScore          string
	TotalScore          string
	CreatedAt           string
	UpdatedAt           string
}{
	ID:                  "player_progress.id",
	PlayerID:            "player_progress.player_id",
	IsOfficial:          "player_progress.is_official",
	KillCount:           "player_progress.kill_count",
	DeathCount:          "player_progress.death_count",
	LeaderKills:         "player_progress.leader_kills",
	AssaultKills:        "player_progress.assault_kills",
	MedicKills:          "player_progress.medic_kills",
	EngineerKills:       "player_progress.engineer_kills",
	SupportKills:        "player_progress.support_kills",
	ReconKills:          "player_progress.recon_kills",
	WinCount:            "player_progress.win_count",
	LoseCount:           "player_progress.lose_count",
	FriendlyShots:       "player_progress.friendly_shots",
	FriendlyKills:       "player_progress.friendly_kills",
	Revived:             "player_progress.revived",
	RevivedTeamMates:    "player_progress.revived_team_mates",
	Assists:             "player_progress.assists",
	Prestige:            "player_progress.prestige",
	CurrentRank:         "player_progress.current_rank",
	Exp:                 "player_progress.exp",
	ShotsFired:          "player_progress.shots_fired",
	ShotsHit:            "player_progress.shots_hit",
	Headshots:           "player_progress.headshots",
	CompletedObjectives: "player_progress.completed_objectives",
	HealedHPS:           "player_progress.healed_hps",
	RoadKills:           "player_progress.road_kills",
	Suicides:            "player_progress.suicides",
	VehiclesDestroyed:   "player_progress.vehicles_destroyed",
	VehicleHPRepaired:   "player_progress.vehicle_hp_repaired",
	LongestKill:         "player_progress.longest_kill",
	PlayTimeSeconds:     "player_progress.play_time_seconds",
	LeaderPlayTime:      "player_progress.leader_play_time",
	AssaultPlayTime:     "player_progress.assault_play_time",
	MedicPlayTime:       "player_progress.medic_play_time",
	EngineerPlayTime:    "player_progress.engineer_play_time",
	SupportPlayTime:     "player_progress.support_play_time",
	ReconPlayTime:       "player_progress.recon_play_time",
	LeaderScore:         "player_progress.leader_score",
	AssaultScore:        "player_progress.assault_score",
	MedicScore:          "player_progress.medic_score",
	EngineerScore:       "player_progress.engineer_score",
	SupportScore:        "player_progress.support_score",
	ReconScore:          "player_progress.recon_score",
	TotalScore:          "player_progress.total_score",
	CreatedAt:           "player_progress.created_at",
	UpdatedAt:           "player_progress.updated_at",
}

// Generated where

type whereHelperint8 struct{ field string }

func (w whereHelperint8) EQ(x int8) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint8) NEQ(x int8) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint8) LT(x int8) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint8) LTE(x int8) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint8) GT(x int8) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint8) GTE(x int8) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint8) IN(slice []int8) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint8) NIN(slice []int8) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperuint struct{ field string }

func (w whereHelperuint) EQ(x uint) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperuint) NEQ(x uint) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperuint) LT(x uint) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperuint) LTE(x uint) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperuint) GT(x uint) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperuint) GTE(x uint) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperuint) IN(slice []uint) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperuint) NIN(slice []uint) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

var PlayerProgressWhere = struct {
	ID                  whereHelperint
	PlayerID            whereHelperint
	IsOfficial          whereHelperint8
	KillCount           whereHelperuint
	DeathCount          whereHelperuint
	LeaderKills         whereHelperuint
	AssaultKills        whereHelperuint
	MedicKills          whereHelperuint
	EngineerKills       whereHelperuint
	SupportKills        whereHelperuint
	ReconKills          whereHelperuint
	WinCount            whereHelperuint
	LoseCount           whereHelperuint
	FriendlyShots       whereHelperuint
	FriendlyKills       whereHelperuint
	Revived             whereHelperuint
	RevivedTeamMates    whereHelperuint
	Assists             whereHelperuint
	Prestige            whereHelperuint
	CurrentRank         whereHelperuint
	Exp                 whereHelperuint
	ShotsFired          whereHelperuint
	ShotsHit            whereHelperuint
	Headshots           whereHelperuint
	CompletedObjectives whereHelperuint
	HealedHPS           whereHelperuint
	RoadKills           whereHelperuint
	Suicides            whereHelperuint
	VehiclesDestroyed   whereHelperuint
	VehicleHPRepaired   whereHelperuint
	LongestKill         whereHelperuint
	PlayTimeSeconds     whereHelperuint
	LeaderPlayTime      whereHelperuint
	AssaultPlayTime     whereHelperuint
	MedicPlayTime       whereHelperuint
	EngineerPlayTime    whereHelperuint
	SupportPlayTime     whereHelperuint
	ReconPlayTime       whereHelperuint
	LeaderScore         whereHelperuint
	AssaultScore        whereHelperuint
	MedicScore          whereHelperuint
	EngineerScore       whereHelperuint
	SupportScore        whereHelperuint
	ReconScore          whereHelperuint
	TotalScore          whereHelperuint
	CreatedAt           whereHelpertime_Time
	UpdatedAt           whereHelpertime_Time
}{
	ID:                  whereHelperint{field: "`player_progress`.`id`"},
	PlayerID:            whereHelperint{field: "`player_progress`.`player_id`"},
	IsOfficial:          whereHelperint8{field: "`player_progress`.`is_official`"},
	KillCount:           whereHelperuint{field: "`player_progress`.`kill_count`"},
	DeathCount:          whereHelperuint{field: "`player_progress`.`death_count`"},
	LeaderKills:         whereHelperuint{field: "`player_progress`.`leader_kills`"},
	AssaultKills:        whereHelperuint{field: "`player_progress`.`assault_kills`"},
	MedicKills:          whereHelperuint{field: "`player_progress`.`medic_kills`"},
	EngineerKills:       whereHelperuint{field: "`player_progress`.`engineer_kills`"},
	SupportKills:        whereHelperuint{field: "`player_progress`.`support_kills`"},
	ReconKills:          whereHelperuint{field: "`player_progress`.`recon_kills`"},
	WinCount:            whereHelperuint{field: "`player_progress`.`win_count`"},
	LoseCount:           whereHelperuint{field: "`player_progress`.`lose_count`"},
	FriendlyShots:       whereHelperuint{field: "`player_progress`.`friendly_shots`"},
	FriendlyKills:       whereHelperuint{field: "`player_progress`.`friendly_kills`"},
	Revived:             whereHelperuint{field: "`player_progress`.`revived`"},
	RevivedTeamMates:    whereHelperuint{field: "`player_progress`.`revived_team_mates`"},
	Assists:             whereHelperuint{field: "`player_progress`.`assists`"},
	Prestige:            whereHelperuint{field: "`player_progress`.`prestige`"},
	CurrentRank:         whereHelperuint{field: "`player_progress`.`current_rank`"},
	Exp:                 whereHelperuint{field: "`player_progress`.`exp`"},
	ShotsFired:          whereHelperuint{field: "`player_progress`.`shots_fired`"},
	ShotsHit:            whereHelperuint{field: "`player_progress`.`shots_hit`"},
	Headshots:           whereHelperuint{field: "`player_progress`.`headshots`"},
	CompletedObjectives: whereHelperuint{field: "`player_progress`.`completed_objectives`"},
	HealedHPS:           whereHelperuint{field: "`player_progress`.`healed_hps`"},
	RoadKills:           whereHelperuint{field: "`player_progress`.`road_kills`"},
	Suicides:            whereHelperuint{field: "`player_progress`.`suicides`"},
	VehiclesDestroyed:   whereHelperuint{field: "`player_progress`.`vehicles_destroyed`"},
	VehicleHPRepaired:   whereHelperuint{field: "`player_progress`.`vehicle_hp_repaired`"},
	LongestKill:         whereHelperuint{field: "`player_progress`.`longest_kill`"},
	PlayTimeSeconds:     whereHelperuint{field: "`player_progress`.`play_time_seconds`"},
	LeaderPlayTime:      whereHelperuint{field: "`player_progress`.`leader_play_time`"},
	AssaultPlayTime:     whereHelperuint{field: "`player_progress`.`assault_play_time`"},
	MedicPlayTime:       whereHelperuint{field: "`player_progress`.`medic_play_time`"},
	EngineerPlayTime:    whereHelperuint{field: "`player_progress`.`engineer_play_time`"},
	SupportPlayTime:     whereHelperuint{field: "`player_progress`.`support_play_time`"},
	ReconPlayTime:       whereHelperuint{field: "`player_progress`.`recon_play_time`"},
	LeaderScore:         whereHelperuint{field: "`player_progress`.`leader_score`"},
	AssaultScore:        whereHelperuint{field: "`player_progress`.`assault_score`"},
	MedicScore:          whereHelperuint{field: "`player_progress`.`medic_score`"},
	EngineerScore:       whereHelperuint{field: "`player_progress`.`engineer_score`"},
	SupportScore:        whereHelperuint{field: "`player_progress`.`support_score`"},
	ReconScore:          whereHelperuint{field: "`player_progress`.`recon_score`"},
	TotalScore:          whereHelperuint{field: "`player_progress`.`total_score`"},
	CreatedAt:           whereHelpertime_Time{field: "`player_progress`.`created_at`"},
	UpdatedAt:           whereHelpertime_Time{field: "`player_progress`.`updated_at`"},
}

// PlayerProgressRels is where relationship names are stored.
var PlayerProgressRels = struct {
	Player string
}{
	Player: "Player",
}

// playerProgressR is where relationships are stored.
type playerProgressR struct {
	Player *Player `boil:"Player" json:"Player" toml:"Player" yaml:"Player"`
}

// NewStruct creates a new relationship struct
func (*playerProgressR) NewStruct() *playerProgressR {
	return &playerProgressR{}
}

func (r *playerProgressR) GetPlayer() *Player {
	if r == nil {
		return nil
	}
	return r.Player
}

// playerProgressL is where Load methods for each relationship are stored.
type playerProgressL struct{}

var (
	playerProgressAllColumns            = []string{"id", "player_id", "is_official", "kill_count", "death_count", "leader_kills", "assault_kills", "medic_kills", "engineer_kills", "support_kills", "recon_kills", "win_count", "lose_count", "friendly_shots", "friendly_kills", "revived", "revived_team_mates", "assists", "prestige", "current_rank", "exp", "shots_fired", "shots_hit", "headshots", "completed_objectives", "healed_hps", "road_kills", "suicides", "vehicles_destroyed", "vehicle_hp_repaired", "longest_kill", "play_time_seconds", "leader_play_time", "assault_play_time", "medic_play_time", "engineer_play_time", "support_play_time", "recon_play_time", "leader_score", "assault_score", "medic_score", "engineer_score", "support_score", "recon_score", "total_score", "created_at", "updated_at"}
	playerProgressColumnsWithoutDefault = []string{"player_id", "is_official"}
	playerProgressColumnsWithDefault    = []string{"id", "kill_count", "death_count", "leader_kills", "assault_kills", "medic_kills", "engineer_kills", "support_kills", "recon_kills", "win_count", "lose_count", "friendly_shots", "friendly_kills", "revived", "revived_team_mates", "assists", "prestige", "current_rank", "exp", "shots_fired", "shots_hit", "headshots", "completed_objectives", "healed_hps", "road_kills", "suicides", "vehicles_destroyed", "vehicle_hp_repaired", "longest_kill", "play_time_seconds", "leader_play_time", "assault_play_time", "medic_play_time", "engineer_play_time", "support_play_time", "recon_play_time", "leader_score", "assault_score", "medic_score", "engineer_score", "support_score", "recon_score", "total_score", "created_at", "updated_at"}
	playerProgressPrimaryKeyColumns     = []string{"id"}
	playerProgressGeneratedColumns      = []string{}
)

type (
	// PlayerProgressSlice is an alias for a slice of pointers to PlayerProgress.
	// This should almost always be used instead of []PlayerProgress.
	PlayerProgressSlice []*PlayerProgress

	playerProgressQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	playerProgressType                 = reflect.TypeOf(&PlayerProgress{})
	playerProgressMapping              = queries.MakeStructMapping(playerProgressType)
	playerProgressPrimaryKeyMapping, _ = queries.BindMapping(playerProgressType, playerProgressMapping, playerProgressPrimaryKeyColumns)
	playerProgressInsertCacheMut       sync.RWMutex
	playerProgressInsertCache          = make(map[string]insertCache)
	playerProgressUpdateCacheMut       sync.RWMutex
	playerProgressUpdateCache          = make(map[string]updateCache)
	playerProgressUpsertCacheMut       sync.RWMutex
	playerProgressUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single playerProgress record from the query.
func (q playerProgressQuery) One(exec boil.Executor) (*PlayerProgress, error) {
	o := &PlayerProgress{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: failed to execute a one query for player_progress")
	}

	return o, nil
}

// All returns all PlayerProgress records from the query.
func (q playerProgressQuery) All(exec boil.Executor) (PlayerProgressSlice, error) {
	var o []*PlayerProgress

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "model: failed to assign all query results to PlayerProgress slice")
	}

	return o, nil
}

// Count returns the count of all PlayerProgress records in the query.
func (q playerProgressQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "model: failed to count player_progress rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q playerProgressQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "model: failed to check if player_progress exists")
	}

	return count > 0, nil
}

// Player pointed to by the foreign key.
func (o *PlayerProgress) Player(mods ...qm.QueryMod) playerQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.PlayerID),
	}

	queryMods = append(queryMods, mods...)

	return Players(queryMods...)
}

// LoadPlayer allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (playerProgressL) LoadPlayer(e boil.Executor, singular bool, maybePlayerProgress interface{}, mods queries.Applicator) error {
	var slice []*PlayerProgress
	var object *PlayerProgress

	if singular {
		var ok bool
		object, ok = maybePlayerProgress.(*PlayerProgress)
		if !ok {
			object = new(PlayerProgress)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayerProgress)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayerProgress))
			}
		}
	} else {
		s, ok := maybePlayerProgress.(*[]*PlayerProgress)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayerProgress)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayerProgress))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &playerProgressR{}
		}
		args = append(args, object.PlayerID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerProgressR{}
			}

			for _, a := range args {
				if a == obj.PlayerID {
					continue Outer
				}
			}

			args = append(args, obj.PlayerID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`player`),
		qm.WhereIn(`player.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Player")
	}

	var resultSlice []*Player
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Player")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for player")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Player = foreign
		if foreign.R == nil {
			foreign.R = &playerR{}
		}
		foreign.R.PlayerProgresses = append(foreign.R.PlayerProgresses, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PlayerID == foreign.ID {
				local.R.Player = foreign
				if foreign.R == nil {
					foreign.R = &playerR{}
				}
				foreign.R.PlayerProgresses = append(foreign.R.PlayerProgresses, local)
				break
			}
		}
	}

	return nil
}

// SetPlayer of the playerProgress to the related item.
// Sets o.R.Player to related.
// Adds o to related.R.PlayerProgresses.
func (o *PlayerProgress) SetPlayer(exec boil.Executor, insert bool, related *Player) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `player_progress` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"player_id"}),
		strmangle.WhereClause("`", "`", 0, playerProgressPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PlayerID = related.ID
	if o.R == nil {
		o.R = &playerProgressR{
			Player: related,
		}
	} else {
		o.R.Player = related
	}

	if related.R == nil {
		related.R = &playerR{
			PlayerProgresses: PlayerProgressSlice{o},
		}
	} else {
		related.R.PlayerProgresses = append(related.R.PlayerProgresses, o)
	}

	return nil
}

// PlayerProgresses retrieves all the records using an executor.
func PlayerProgresses(mods ...qm.QueryMod) playerProgressQuery {
	mods = append(mods, qm.From("`player_progress`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`player_progress`.*"})
	}

	return playerProgressQuery{q}
}

// FindPlayerProgress retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPlayerProgress(exec boil.Executor, iD int, selectCols ...string) (*PlayerProgress, error) {
	playerProgressObj := &PlayerProgress{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `player_progress` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, playerProgressObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "model: unable to select from player_progress")
	}

	return playerProgressObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *PlayerProgress) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("model: no player_progress provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(playerProgressColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	playerProgressInsertCacheMut.RLock()
	cache, cached := playerProgressInsertCache[key]
	playerProgressInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			playerProgressAllColumns,
			playerProgressColumnsWithDefault,
			playerProgressColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(playerProgressType, playerProgressMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(playerProgressType, playerProgressMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `player_progress` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `player_progress` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `player_progress` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, playerProgressPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	result, err := exec.Exec(cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to insert into player_progress")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == playerProgressMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}
	err = exec.QueryRow(cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for player_progress")
	}

CacheNoHooks:
	if !cached {
		playerProgressInsertCacheMut.Lock()
		playerProgressInsertCache[key] = cache
		playerProgressInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the PlayerProgress.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *PlayerProgress) Update(exec boil.Executor, columns boil.Columns) error {
	var err error
	key := makeCacheKey(columns, nil)
	playerProgressUpdateCacheMut.RLock()
	cache, cached := playerProgressUpdateCache[key]
	playerProgressUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			playerProgressAllColumns,
			playerProgressPrimaryKeyColumns,
		)
		if len(wl) == 0 {
			return errors.New("model: unable to update player_progress, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `player_progress` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, playerProgressPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(playerProgressType, playerProgressMapping, append(wl, playerProgressPrimaryKeyColumns...))
		if err != nil {
			return err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err = exec.Exec(cache.query, values...)
	if err != nil {
		return errors.Wrap(err, "model: unable to update player_progress row")
	}

	if !cached {
		playerProgressUpdateCacheMut.Lock()
		playerProgressUpdateCache[key] = cache
		playerProgressUpdateCacheMut.Unlock()
	}

	return nil
}

// UpdateAll updates all rows with the specified column values.
func (q playerProgressQuery) UpdateAll(exec boil.Executor, cols M) error {
	queries.SetUpdate(q.Query, cols)

	_, err := q.Query.Exec(exec)
	if err != nil {
		return errors.Wrap(err, "model: unable to update all for player_progress")
	}

	return nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PlayerProgressSlice) UpdateAll(exec boil.Executor, cols M) error {
	ln := int64(len(o))
	if ln == 0 {
		return nil
	}

	if len(cols) == 0 {
		return errors.New("model: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerProgressPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `player_progress` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, playerProgressPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "model: unable to update all in playerProgress slice")
	}

	return nil
}

var mySQLPlayerProgressUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *PlayerProgress) Upsert(exec boil.Executor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("model: no player_progress provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(playerProgressColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLPlayerProgressUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	playerProgressUpsertCacheMut.RLock()
	cache, cached := playerProgressUpsertCache[key]
	playerProgressUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			playerProgressAllColumns,
			playerProgressColumnsWithDefault,
			playerProgressColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			playerProgressAllColumns,
			playerProgressPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("model: unable to upsert player_progress, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`player_progress`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `player_progress` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(playerProgressType, playerProgressMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(playerProgressType, playerProgressMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	result, err := exec.Exec(cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "model: unable to upsert for player_progress")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == playerProgressMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(playerProgressType, playerProgressMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "model: unable to retrieve unique values for player_progress")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}
	err = exec.QueryRow(cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "model: unable to populate default values for player_progress")
	}

CacheNoHooks:
	if !cached {
		playerProgressUpsertCacheMut.Lock()
		playerProgressUpsertCache[key] = cache
		playerProgressUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single PlayerProgress record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *PlayerProgress) Delete(exec boil.Executor) error {
	if o == nil {
		return errors.New("model: no PlayerProgress provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), playerProgressPrimaryKeyMapping)
	sql := "DELETE FROM `player_progress` WHERE `id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "model: unable to delete from player_progress")
	}

	return nil
}

// DeleteAll deletes all matching rows.
func (q playerProgressQuery) DeleteAll(exec boil.Executor) error {
	if q.Query == nil {
		return errors.New("model: no playerProgressQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	_, err := q.Query.Exec(exec)
	if err != nil {
		return errors.Wrap(err, "model: unable to delete all from player_progress")
	}

	return nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PlayerProgressSlice) DeleteAll(exec boil.Executor) error {
	if len(o) == 0 {
		return nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerProgressPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `player_progress` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, playerProgressPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	_, err := exec.Exec(sql, args...)
	if err != nil {
		return errors.Wrap(err, "model: unable to delete all from playerProgress slice")
	}

	return nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *PlayerProgress) Reload(exec boil.Executor) error {
	ret, err := FindPlayerProgress(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PlayerProgressSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PlayerProgressSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerProgressPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `player_progress`.* FROM `player_progress` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, playerProgressPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "model: unable to reload all in PlayerProgressSlice")
	}

	*o = slice

	return nil
}

// PlayerProgressExists checks if the PlayerProgress row exists.
func PlayerProgressExists(exec boil.Executor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `player_progress` where `id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "model: unable to check if player_progress exists")
	}

	return exists, nil
}

// Exists checks if the PlayerProgress row exists.
func (o *PlayerProgress) Exists(exec boil.Executor) (bool, error) {
	return PlayerProgressExists(exec, o.ID)
}
